{
  "entities": {
    "ServiceRecord": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "ServiceRecord",
      "type": "object",
      "description": "Represents a record of a service performed, including details about the customer, equipment, work done, and costs.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the service record."
        },
        "date": {
          "type": "string",
          "description": "Date when the service was performed.",
          "format": "date-time"
        },
        "technicianId": {
          "type": "string",
          "description": "Reference to the Technician who performed the service. (Relationship: Technician 1:N ServiceRecord)"
        },
        "customerId": {
          "type": "string",
          "description": "Reference to the Customer who received the service. (Relationship: Customer 1:N ServiceRecord)"
        },
        "address": {
          "type": "string",
          "description": "Address where the service was performed."
        },
        "phone": {
          "type": "string",
          "description": "Phone number associated with the service location."
        },
        "equipmentModel": {
          "type": "string",
          "description": "Model number of the equipment serviced."
        },
        "equipmentSerial": {
          "type": "string",
          "description": "Serial number of the equipment serviced."
        },
        "filterSize": {
          "type": "string",
          "description": "Size of the filter used, if applicable."
        },
        "freonType": {
          "type": "string",
          "description": "Type of freon used, if applicable."
        },
        "laborHours": {
          "type": "number",
          "description": "Number of labor hours spent on the service."
        },
        "workDescription": {
          "type": "string",
          "description": "Detailed description of the work performed."
        },
        "totalCost": {
          "type": "number",
          "description": "Total cost of the service."
        },
        "status": {
          "type": "string",
          "description": "Status of the service record (e.g., 'Owed', 'Paid', 'Estimate')."
        },
        "fileLink": {
          "type": "string",
          "description": "Link to the original document file.",
          "format": "uri"
        },
        "page": {
          "type": "number",
          "description": "Page number in the original document where the service record is found."
        },
        "recordSummary": {
          "type": "string",
          "description": "A summarized description of the service record, generated by AI."
        }
      },
      "required": [
        "id",
        "date",
        "technicianId",
        "customerId",
        "address",
        "phone",
        "equipmentModel",
        "equipmentSerial",
        "laborHours",
        "workDescription",
        "totalCost",
        "status"
      ]
    },
    "Customer": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Customer",
      "type": "object",
      "description": "Represents a customer who receives services.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the customer."
        },
        "name": {
          "type": "string",
          "description": "Name of the customer."
        },
        "address": {
          "type": "string",
          "description": "Address of the customer."
        },
        "phone": {
          "type": "string",
          "description": "Phone number of the customer."
        },
        "email": {
          "type": "string",
          "description": "Email of the customer.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "name",
        "address",
        "phone"
      ]
    },
    "Technician": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Technician",
      "type": "object",
      "description": "Represents a technician who performs services.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the technician."
        },
        "name": {
          "type": "string",
          "description": "Name of the technician."
        },
        "phone": {
          "type": "string",
          "description": "Phone number of the technician."
        },
        "email": {
          "type": "string",
          "description": "Email of the technician.",
          "format": "email"
        }
      },
      "required": [
        "id",
        "name"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/technicians/{technicianId}",
        "definition": {
          "entityName": "Technician",
          "schema": {
            "$ref": "#/backend/entities/Technician"
          },
          "description": "Stores technician profiles. Technician can read their own profile data.",
          "params": [
            {
              "name": "technicianId",
              "description": "The unique identifier for the technician."
            }
          ]
        }
      },
      {
        "path": "/customers/{customerId}",
        "definition": {
          "entityName": "Customer",
          "schema": {
            "$ref": "#/backend/entities/Customer"
          },
          "description": "Stores customer profiles. Customer can read their own profile data.",
          "params": [
            {
              "name": "customerId",
              "description": "The unique identifier for the customer."
            }
          ]
        }
      },
      {
        "path": "/technicians/{technicianId}/serviceRecords/{serviceRecordId}",
        "definition": {
          "entityName": "ServiceRecord",
          "schema": {
            "$ref": "#/backend/entities/ServiceRecord"
          },
          "description": "Stores service records associated with a technician. Includes denormalized 'technicianId' for authorization independence.",
          "params": [
            {
              "name": "technicianId",
              "description": "The unique identifier for the technician."
            },
            {
              "name": "serviceRecordId",
              "description": "The unique identifier for the service record."
            }
          ]
        }
      },
      {
        "path": "/customers/{customerId}/serviceRecords/{serviceRecordId}",
        "definition": {
          "entityName": "ServiceRecord",
          "schema": {
            "$ref": "#/backend/entities/ServiceRecord"
          },
          "description": "Stores service records associated with a customer. Includes denormalized 'customerId' for authorization independence.",
          "params": [
            {
              "name": "customerId",
              "description": "The unique identifier for the customer."
            },
            {
              "name": "serviceRecordId",
              "description": "The unique identifier for the service record."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to be secure, scalable, and easily debuggable, adhering to the core design principles and strategy mandates. It prioritizes authorization independence through denormalization, ensuring that security rules can be simple and robust. The structure supports the required QAPs by segregating data with different access needs into separate collections.\n\nAuthorization Independence:\nServiceRecord subcollections under technician and customer will contain denormalized copies of technicianId and customerId in each document.\n\nQAPs:\nList operations are secured by the path-based ownership, allowing the list function to be performed without get() calls.\n\nEach collection is designed with a homogeneous security posture, making rules easier to understand and maintain. The use of explicit state modeling with the 'status' field ensures data clarity and predictability."
  }
}